# coding: utf-8

"""
    Blackfynn Swagger

    Swagger documentation for the Blackfynn api  # noqa: E501

    OpenAPI spec version: 1.0.0
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from datcore_sdk.api_client import ApiClient


class TimeSeriesApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def create_channel(self, id, time_series_channel_write_request, **kwargs):  # noqa: E501
        """saves channels to the time series package  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_channel(id, time_series_channel_write_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param list[TimeSeriesChannelWriteRequest] time_series_channel_write_request: (required)
        :return: ChannelDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_channel_with_http_info(id, time_series_channel_write_request, **kwargs)  # noqa: E501
        else:
            (data) = self.create_channel_with_http_info(id, time_series_channel_write_request, **kwargs)  # noqa: E501
            return data

    def create_channel_with_http_info(self, id, time_series_channel_write_request, **kwargs):  # noqa: E501
        """saves channels to the time series package  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_channel_with_http_info(id, time_series_channel_write_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param list[TimeSeriesChannelWriteRequest] time_series_channel_write_request: (required)
        :return: ChannelDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id', 'time_series_channel_write_request']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_channel" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `create_channel`")  # noqa: E501
        # verify the required parameter 'time_series_channel_write_request' is set
        if ('time_series_channel_write_request' not in local_var_params or
                local_var_params['time_series_channel_write_request'] is None):
            raise ValueError("Missing the required parameter `time_series_channel_write_request` when calling `create_channel`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'time_series_channel_write_request' in local_var_params:
            body_params = local_var_params['time_series_channel_write_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/timeseries/{id}/channels', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ChannelDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_time_series_annotation(self, id, layer_id, time_series_annotation_write_request, **kwargs):  # noqa: E501
        """Create an annotation for the given time series id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_time_series_annotation(id, layer_id, time_series_annotation_write_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Id of the time series the annotation will belong to (required)
        :param str layer_id: Id of the time series layer the annotation will belong to (required)
        :param TimeSeriesAnnotationWriteRequest time_series_annotation_write_request: annotations to write (required)
        :return: TimeSeriesAnnotation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_time_series_annotation_with_http_info(id, layer_id, time_series_annotation_write_request, **kwargs)  # noqa: E501
        else:
            (data) = self.create_time_series_annotation_with_http_info(id, layer_id, time_series_annotation_write_request, **kwargs)  # noqa: E501
            return data

    def create_time_series_annotation_with_http_info(self, id, layer_id, time_series_annotation_write_request, **kwargs):  # noqa: E501
        """Create an annotation for the given time series id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_time_series_annotation_with_http_info(id, layer_id, time_series_annotation_write_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Id of the time series the annotation will belong to (required)
        :param str layer_id: Id of the time series layer the annotation will belong to (required)
        :param TimeSeriesAnnotationWriteRequest time_series_annotation_write_request: annotations to write (required)
        :return: TimeSeriesAnnotation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id', 'layer_id', 'time_series_annotation_write_request']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_time_series_annotation" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `create_time_series_annotation`")  # noqa: E501
        # verify the required parameter 'layer_id' is set
        if ('layer_id' not in local_var_params or
                local_var_params['layer_id'] is None):
            raise ValueError("Missing the required parameter `layer_id` when calling `create_time_series_annotation`")  # noqa: E501
        # verify the required parameter 'time_series_annotation_write_request' is set
        if ('time_series_annotation_write_request' not in local_var_params or
                local_var_params['time_series_annotation_write_request'] is None):
            raise ValueError("Missing the required parameter `time_series_annotation_write_request` when calling `create_time_series_annotation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'layer_id' in local_var_params:
            path_params['layerId'] = local_var_params['layer_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'time_series_annotation_write_request' in local_var_params:
            body_params = local_var_params['time_series_annotation_write_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/timeseries/{id}/layers/{layerId}/annotations', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TimeSeriesAnnotation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_time_series_layer(self, id, layer_request, **kwargs):  # noqa: E501
        """create time series layer for use with the given layer  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_time_series_layer(id, layer_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Id of the time series to create this layer for (required)
        :param LayerRequest layer_request: Properties of the layer to create (required)
        :return: TimeSeriesLayer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_time_series_layer_with_http_info(id, layer_request, **kwargs)  # noqa: E501
        else:
            (data) = self.create_time_series_layer_with_http_info(id, layer_request, **kwargs)  # noqa: E501
            return data

    def create_time_series_layer_with_http_info(self, id, layer_request, **kwargs):  # noqa: E501
        """create time series layer for use with the given layer  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_time_series_layer_with_http_info(id, layer_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Id of the time series to create this layer for (required)
        :param LayerRequest layer_request: Properties of the layer to create (required)
        :return: TimeSeriesLayer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id', 'layer_request']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_time_series_layer" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `create_time_series_layer`")  # noqa: E501
        # verify the required parameter 'layer_request' is set
        if ('layer_request' not in local_var_params or
                local_var_params['layer_request'] is None):
            raise ValueError("Missing the required parameter `layer_request` when calling `create_time_series_layer`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'layer_request' in local_var_params:
            body_params = local_var_params['layer_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/timeseries/{id}/layers', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TimeSeriesLayer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_channel(self, id, channel_id, **kwargs):  # noqa: E501
        """delete an existing channel object in the graph  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_channel(id, channel_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str channel_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_channel_with_http_info(id, channel_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_channel_with_http_info(id, channel_id, **kwargs)  # noqa: E501
            return data

    def delete_channel_with_http_info(self, id, channel_id, **kwargs):  # noqa: E501
        """delete an existing channel object in the graph  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_channel_with_http_info(id, channel_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str channel_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id', 'channel_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_channel" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_channel`")  # noqa: E501
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in local_var_params or
                local_var_params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `delete_channel`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'channel_id' in local_var_params:
            path_params['channelId'] = local_var_params['channel_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/timeseries/{id}/channels/{channelId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_time_series_annotation(self, id, layer_id, annotation_id, **kwargs):  # noqa: E501
        """delete the annotation with the given id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_time_series_annotation(id, layer_id, annotation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Time series package id the annotation belongs to (required)
        :param int layer_id: Id of the layer the annotation belongs to (required)
        :param int annotation_id: Id of the annotation to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_time_series_annotation_with_http_info(id, layer_id, annotation_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_time_series_annotation_with_http_info(id, layer_id, annotation_id, **kwargs)  # noqa: E501
            return data

    def delete_time_series_annotation_with_http_info(self, id, layer_id, annotation_id, **kwargs):  # noqa: E501
        """delete the annotation with the given id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_time_series_annotation_with_http_info(id, layer_id, annotation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Time series package id the annotation belongs to (required)
        :param int layer_id: Id of the layer the annotation belongs to (required)
        :param int annotation_id: Id of the annotation to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id', 'layer_id', 'annotation_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_time_series_annotation" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_time_series_annotation`")  # noqa: E501
        # verify the required parameter 'layer_id' is set
        if ('layer_id' not in local_var_params or
                local_var_params['layer_id'] is None):
            raise ValueError("Missing the required parameter `layer_id` when calling `delete_time_series_annotation`")  # noqa: E501
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in local_var_params or
                local_var_params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `delete_time_series_annotation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'layer_id' in local_var_params:
            path_params['layerId'] = local_var_params['layer_id']  # noqa: E501
        if 'annotation_id' in local_var_params:
            path_params['annotationId'] = local_var_params['annotation_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/timeseries/{id}/layers/{layerId}/annotations/{annotationId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_time_series_annotations(self, id, layer_id, request_body, **kwargs):  # noqa: E501
        """delete the annotations with the given ids that belong to this time series package and layer  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_time_series_annotations(id, layer_id, request_body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Time series package id the annotation belongs to (required)
        :param int layer_id: Id of the layer the annotation belongs to (required)
        :param list[int] request_body: Ids of the annotations to delete. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_time_series_annotations_with_http_info(id, layer_id, request_body, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_time_series_annotations_with_http_info(id, layer_id, request_body, **kwargs)  # noqa: E501
            return data

    def delete_time_series_annotations_with_http_info(self, id, layer_id, request_body, **kwargs):  # noqa: E501
        """delete the annotations with the given ids that belong to this time series package and layer  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_time_series_annotations_with_http_info(id, layer_id, request_body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Time series package id the annotation belongs to (required)
        :param int layer_id: Id of the layer the annotation belongs to (required)
        :param list[int] request_body: Ids of the annotations to delete. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id', 'layer_id', 'request_body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_time_series_annotations" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_time_series_annotations`")  # noqa: E501
        # verify the required parameter 'layer_id' is set
        if ('layer_id' not in local_var_params or
                local_var_params['layer_id'] is None):
            raise ValueError("Missing the required parameter `layer_id` when calling `delete_time_series_annotations`")  # noqa: E501
        # verify the required parameter 'request_body' is set
        if ('request_body' not in local_var_params or
                local_var_params['request_body'] is None):
            raise ValueError("Missing the required parameter `request_body` when calling `delete_time_series_annotations`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'layer_id' in local_var_params:
            path_params['layerId'] = local_var_params['layer_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'request_body' in local_var_params:
            body_params = local_var_params['request_body']
        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/timeseries/{id}/layers/{layerId}/annotations', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_time_series_layer(self, id, layer_id, **kwargs):  # noqa: E501
        """delete layer for the given time series id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_time_series_layer(id, layer_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Id of the time series this layer belongs to (required)
        :param int layer_id: Id of the layer to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_time_series_layer_with_http_info(id, layer_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_time_series_layer_with_http_info(id, layer_id, **kwargs)  # noqa: E501
            return data

    def delete_time_series_layer_with_http_info(self, id, layer_id, **kwargs):  # noqa: E501
        """delete layer for the given time series id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_time_series_layer_with_http_info(id, layer_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Id of the time series this layer belongs to (required)
        :param int layer_id: Id of the layer to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id', 'layer_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_time_series_layer" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_time_series_layer`")  # noqa: E501
        # verify the required parameter 'layer_id' is set
        if ('layer_id' not in local_var_params or
                local_var_params['layer_id'] is None):
            raise ValueError("Missing the required parameter `layer_id` when calling `delete_time_series_layer`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'layer_id' in local_var_params:
            path_params['layerId'] = local_var_params['layer_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/timeseries/{id}/layers/{layerId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_annotations_window(self, id, layer_ids, aggregation, start, end, period, **kwargs):  # noqa: E501
        """get aggregations of annotations based on a sliding window  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_annotations_window(id, layer_ids, aggregation, start, end, period, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Id of the timeseries package to aggregate annotations for (required)
        :param list[int] layer_ids: Ids of the layers the annotations belong to. Multiparameter - specify as layerIds=1&layerIds=2... (required)
        :param str aggregation: Aggregation function to run over the values of the annotations (required)
        :param int start: The starting time of the range to query over in microseconds (inclusive) (required)
        :param int end: The ending time of the the range to query over in microseconds (exclusive) (required)
        :param int period: The length of time to group the counts of annotations by in microseconds (required)
        :param list[str] channel_ids: list of channel ids If absent, use all channels. Multiparameter - specify as channelIds=abc&channelIds=def... 
        :param bool merge_periods: merge consecutive result periods together to reduce the size of the result payload
        :return: dict(str, list[AnnotationAggregateWindowResultOptionLong])
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_annotations_window_with_http_info(id, layer_ids, aggregation, start, end, period, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_annotations_window_with_http_info(id, layer_ids, aggregation, start, end, period, **kwargs)  # noqa: E501
            return data

    def get_all_annotations_window_with_http_info(self, id, layer_ids, aggregation, start, end, period, **kwargs):  # noqa: E501
        """get aggregations of annotations based on a sliding window  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_annotations_window_with_http_info(id, layer_ids, aggregation, start, end, period, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Id of the timeseries package to aggregate annotations for (required)
        :param list[int] layer_ids: Ids of the layers the annotations belong to. Multiparameter - specify as layerIds=1&layerIds=2... (required)
        :param str aggregation: Aggregation function to run over the values of the annotations (required)
        :param int start: The starting time of the range to query over in microseconds (inclusive) (required)
        :param int end: The ending time of the the range to query over in microseconds (exclusive) (required)
        :param int period: The length of time to group the counts of annotations by in microseconds (required)
        :param list[str] channel_ids: list of channel ids If absent, use all channels. Multiparameter - specify as channelIds=abc&channelIds=def... 
        :param bool merge_periods: merge consecutive result periods together to reduce the size of the result payload
        :return: dict(str, list[AnnotationAggregateWindowResultOptionLong])
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id', 'layer_ids', 'aggregation', 'start', 'end', 'period', 'channel_ids', 'merge_periods']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_annotations_window" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_all_annotations_window`")  # noqa: E501
        # verify the required parameter 'layer_ids' is set
        if ('layer_ids' not in local_var_params or
                local_var_params['layer_ids'] is None):
            raise ValueError("Missing the required parameter `layer_ids` when calling `get_all_annotations_window`")  # noqa: E501
        # verify the required parameter 'aggregation' is set
        if ('aggregation' not in local_var_params or
                local_var_params['aggregation'] is None):
            raise ValueError("Missing the required parameter `aggregation` when calling `get_all_annotations_window`")  # noqa: E501
        # verify the required parameter 'start' is set
        if ('start' not in local_var_params or
                local_var_params['start'] is None):
            raise ValueError("Missing the required parameter `start` when calling `get_all_annotations_window`")  # noqa: E501
        # verify the required parameter 'end' is set
        if ('end' not in local_var_params or
                local_var_params['end'] is None):
            raise ValueError("Missing the required parameter `end` when calling `get_all_annotations_window`")  # noqa: E501
        # verify the required parameter 'period' is set
        if ('period' not in local_var_params or
                local_var_params['period'] is None):
            raise ValueError("Missing the required parameter `period` when calling `get_all_annotations_window`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []
        if 'layer_ids' in local_var_params:
            query_params.append(('layerIds', local_var_params['layer_ids']))  # noqa: E501
            collection_formats['layerIds'] = 'csv'  # noqa: E501
        if 'aggregation' in local_var_params:
            query_params.append(('aggregation', local_var_params['aggregation']))  # noqa: E501
        if 'start' in local_var_params:
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'end' in local_var_params:
            query_params.append(('end', local_var_params['end']))  # noqa: E501
        if 'period' in local_var_params:
            query_params.append(('period', local_var_params['period']))  # noqa: E501
        if 'channel_ids' in local_var_params:
            query_params.append(('channelIds', local_var_params['channel_ids']))  # noqa: E501
            collection_formats['channelIds'] = 'csv'  # noqa: E501
        if 'merge_periods' in local_var_params:
            query_params.append(('mergePeriods', local_var_params['merge_periods']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/timeseries/{id}/annotations/window', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='dict(str, list[AnnotationAggregateWindowResultOptionLong])',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_annotation(self, id, layer_id, include_links, annotation_id, **kwargs):  # noqa: E501
        """Get an annotation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_annotation(id, layer_id, include_links, annotation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Id of the time series the annotation belongs to (required)
        :param int layer_id: Id of the layer the annotations belongs to (required)
        :param bool include_links: whether or not to include attached packages (required)
        :param int annotation_id: Id of the annotation to retrieve (required)
        :return: AnnotationResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_annotation_with_http_info(id, layer_id, include_links, annotation_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_annotation_with_http_info(id, layer_id, include_links, annotation_id, **kwargs)  # noqa: E501
            return data

    def get_annotation_with_http_info(self, id, layer_id, include_links, annotation_id, **kwargs):  # noqa: E501
        """Get an annotation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_annotation_with_http_info(id, layer_id, include_links, annotation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Id of the time series the annotation belongs to (required)
        :param int layer_id: Id of the layer the annotations belongs to (required)
        :param bool include_links: whether or not to include attached packages (required)
        :param int annotation_id: Id of the annotation to retrieve (required)
        :return: AnnotationResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id', 'layer_id', 'include_links', 'annotation_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_annotation" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_annotation`")  # noqa: E501
        # verify the required parameter 'layer_id' is set
        if ('layer_id' not in local_var_params or
                local_var_params['layer_id'] is None):
            raise ValueError("Missing the required parameter `layer_id` when calling `get_annotation`")  # noqa: E501
        # verify the required parameter 'include_links' is set
        if ('include_links' not in local_var_params or
                local_var_params['include_links'] is None):
            raise ValueError("Missing the required parameter `include_links` when calling `get_annotation`")  # noqa: E501
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in local_var_params or
                local_var_params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `get_annotation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'layer_id' in local_var_params:
            path_params['layerId'] = local_var_params['layer_id']  # noqa: E501
        if 'include_links' in local_var_params:
            path_params['includeLinks'] = local_var_params['include_links']  # noqa: E501

        query_params = []
        if 'annotation_id' in local_var_params:
            query_params.append(('annotationId', local_var_params['annotation_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/timeseries/{id}/layers/{layerId}/annotations/{annotationId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AnnotationResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_annotations_window(self, id, layer_id, aggregation, start, end, period, **kwargs):  # noqa: E501
        """get annotations based on a sliding window  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_annotations_window(id, layer_id, aggregation, start, end, period, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Id of the timeseries package to aggregate annotations for (required)
        :param int layer_id: Id of the layer the annotations belongs to (required)
        :param str aggregation: Aggregation function to run over the values of the annotations (required)
        :param int start: The starting time of the range to query over in microseconds (inclusive) (required)
        :param int end: The ending time of the the range to query over in microseconds (exclusive) (required)
        :param int period: The length of time to group the counts of annotations by in microseconds (required)
        :param list[str] channel_ids: list of channel ids (if absent, use all channels)
        :param bool merge_periods: merge consecutive result periods together to reduce the size of the resulting payload
        :return: list[AnnotationAggregateWindowResultOptionLong]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_annotations_window_with_http_info(id, layer_id, aggregation, start, end, period, **kwargs)  # noqa: E501
        else:
            (data) = self.get_annotations_window_with_http_info(id, layer_id, aggregation, start, end, period, **kwargs)  # noqa: E501
            return data

    def get_annotations_window_with_http_info(self, id, layer_id, aggregation, start, end, period, **kwargs):  # noqa: E501
        """get annotations based on a sliding window  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_annotations_window_with_http_info(id, layer_id, aggregation, start, end, period, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Id of the timeseries package to aggregate annotations for (required)
        :param int layer_id: Id of the layer the annotations belongs to (required)
        :param str aggregation: Aggregation function to run over the values of the annotations (required)
        :param int start: The starting time of the range to query over in microseconds (inclusive) (required)
        :param int end: The ending time of the the range to query over in microseconds (exclusive) (required)
        :param int period: The length of time to group the counts of annotations by in microseconds (required)
        :param list[str] channel_ids: list of channel ids (if absent, use all channels)
        :param bool merge_periods: merge consecutive result periods together to reduce the size of the resulting payload
        :return: list[AnnotationAggregateWindowResultOptionLong]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id', 'layer_id', 'aggregation', 'start', 'end', 'period', 'channel_ids', 'merge_periods']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_annotations_window" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_annotations_window`")  # noqa: E501
        # verify the required parameter 'layer_id' is set
        if ('layer_id' not in local_var_params or
                local_var_params['layer_id'] is None):
            raise ValueError("Missing the required parameter `layer_id` when calling `get_annotations_window`")  # noqa: E501
        # verify the required parameter 'aggregation' is set
        if ('aggregation' not in local_var_params or
                local_var_params['aggregation'] is None):
            raise ValueError("Missing the required parameter `aggregation` when calling `get_annotations_window`")  # noqa: E501
        # verify the required parameter 'start' is set
        if ('start' not in local_var_params or
                local_var_params['start'] is None):
            raise ValueError("Missing the required parameter `start` when calling `get_annotations_window`")  # noqa: E501
        # verify the required parameter 'end' is set
        if ('end' not in local_var_params or
                local_var_params['end'] is None):
            raise ValueError("Missing the required parameter `end` when calling `get_annotations_window`")  # noqa: E501
        # verify the required parameter 'period' is set
        if ('period' not in local_var_params or
                local_var_params['period'] is None):
            raise ValueError("Missing the required parameter `period` when calling `get_annotations_window`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'layer_id' in local_var_params:
            path_params['layerId'] = local_var_params['layer_id']  # noqa: E501

        query_params = []
        if 'aggregation' in local_var_params:
            query_params.append(('aggregation', local_var_params['aggregation']))  # noqa: E501
        if 'start' in local_var_params:
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'end' in local_var_params:
            query_params.append(('end', local_var_params['end']))  # noqa: E501
        if 'period' in local_var_params:
            query_params.append(('period', local_var_params['period']))  # noqa: E501
        if 'channel_ids' in local_var_params:
            query_params.append(('channelIds', local_var_params['channel_ids']))  # noqa: E501
            collection_formats['channelIds'] = 'csv'  # noqa: E501
        if 'merge_periods' in local_var_params:
            query_params.append(('mergePeriods', local_var_params['merge_periods']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/timeseries/{id}/layers/{layerId}/annotations/window', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AnnotationAggregateWindowResultOptionLong]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_channel(self, id, channel_id, **kwargs):  # noqa: E501
        """get a single channel that belongs to the time series package  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_channel(id, channel_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str channel_id: (required)
        :return: ChannelDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_channel_with_http_info(id, channel_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_channel_with_http_info(id, channel_id, **kwargs)  # noqa: E501
            return data

    def get_channel_with_http_info(self, id, channel_id, **kwargs):  # noqa: E501
        """get a single channel that belongs to the time series package  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_channel_with_http_info(id, channel_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str channel_id: (required)
        :return: ChannelDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id', 'channel_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_channel" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_channel`")  # noqa: E501
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in local_var_params or
                local_var_params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `get_channel`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'channel_id' in local_var_params:
            path_params['channelId'] = local_var_params['channel_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/timeseries/{id}/channels/{channelId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ChannelDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_channels(self, id, **kwargs):  # noqa: E501
        """gets the channels for a time series package  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_channels(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :return: list[ChannelDTO]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_channels_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_channels_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_channels_with_http_info(self, id, **kwargs):  # noqa: E501
        """gets the channels for a time series package  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_channels_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :return: list[ChannelDTO]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_channels" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_channels`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/timeseries/{id}/channels', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ChannelDTO]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_layers(self, id, **kwargs):  # noqa: E501
        """Get all layers for a timeseries  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_layers(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str name:
        :param int limit:
        :param int offset:
        :return: PagedResponseTimeSeriesLayer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_layers_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_layers_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_layers_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get all layers for a timeseries  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_layers_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str name:
        :param int limit:
        :param int offset:
        :return: PagedResponseTimeSeriesLayer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id', 'name', 'limit', 'offset']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_layers" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_layers`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []
        if 'name' in local_var_params:
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'limit' in local_var_params:
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params:
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/timeseries/{id}/layers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PagedResponseTimeSeriesLayer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_time_series_annotations(self, id, layer_id, start, end, include_links, **kwargs):  # noqa: E501
        """Get annotations based on query params  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_time_series_annotations(id, layer_id, start, end, include_links, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Id of time series object to search in (required)
        :param int layer_id: Id of the layer the annotations belongs to (required)
        :param int start: Start time of search query in microseconds (required)
        :param int end: End time of search query in microseconds (required)
        :param bool include_links: whether or not to include attached packages (required)
        :param list[str] channel_ids: list of channel ids (if absent, use all channels)
        :param int limit:
        :param int offset:
        :param str layer_name: Annotation layer name (if absent, uses \"Default\" layer)
        :return: AnnotationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_time_series_annotations_with_http_info(id, layer_id, start, end, include_links, **kwargs)  # noqa: E501
        else:
            (data) = self.get_time_series_annotations_with_http_info(id, layer_id, start, end, include_links, **kwargs)  # noqa: E501
            return data

    def get_time_series_annotations_with_http_info(self, id, layer_id, start, end, include_links, **kwargs):  # noqa: E501
        """Get annotations based on query params  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_time_series_annotations_with_http_info(id, layer_id, start, end, include_links, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Id of time series object to search in (required)
        :param int layer_id: Id of the layer the annotations belongs to (required)
        :param int start: Start time of search query in microseconds (required)
        :param int end: End time of search query in microseconds (required)
        :param bool include_links: whether or not to include attached packages (required)
        :param list[str] channel_ids: list of channel ids (if absent, use all channels)
        :param int limit:
        :param int offset:
        :param str layer_name: Annotation layer name (if absent, uses \"Default\" layer)
        :return: AnnotationResults
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id', 'layer_id', 'start', 'end', 'include_links', 'channel_ids', 'limit', 'offset', 'layer_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_time_series_annotations" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_time_series_annotations`")  # noqa: E501
        # verify the required parameter 'layer_id' is set
        if ('layer_id' not in local_var_params or
                local_var_params['layer_id'] is None):
            raise ValueError("Missing the required parameter `layer_id` when calling `get_time_series_annotations`")  # noqa: E501
        # verify the required parameter 'start' is set
        if ('start' not in local_var_params or
                local_var_params['start'] is None):
            raise ValueError("Missing the required parameter `start` when calling `get_time_series_annotations`")  # noqa: E501
        # verify the required parameter 'end' is set
        if ('end' not in local_var_params or
                local_var_params['end'] is None):
            raise ValueError("Missing the required parameter `end` when calling `get_time_series_annotations`")  # noqa: E501
        # verify the required parameter 'include_links' is set
        if ('include_links' not in local_var_params or
                local_var_params['include_links'] is None):
            raise ValueError("Missing the required parameter `include_links` when calling `get_time_series_annotations`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'layer_id' in local_var_params:
            path_params['layerId'] = local_var_params['layer_id']  # noqa: E501
        if 'include_links' in local_var_params:
            path_params['includeLinks'] = local_var_params['include_links']  # noqa: E501

        query_params = []
        if 'start' in local_var_params:
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'end' in local_var_params:
            query_params.append(('end', local_var_params['end']))  # noqa: E501
        if 'channel_ids' in local_var_params:
            query_params.append(('channelIds', local_var_params['channel_ids']))  # noqa: E501
            collection_formats['channelIds'] = 'csv'  # noqa: E501
        if 'limit' in local_var_params:
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'offset' in local_var_params:
            query_params.append(('offset', local_var_params['offset']))  # noqa: E501
        if 'layer_name' in local_var_params:
            query_params.append(('layerName', local_var_params['layer_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/timeseries/{id}/layers/{layerId}/annotations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AnnotationResults',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_time_series_layer(self, id, layer_id, **kwargs):  # noqa: E501
        """get a layer for the given time series id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_time_series_layer(id, layer_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Id of the time series this layer belongs to (required)
        :param int layer_id: Id of the layer to retrieve (required)
        :return: TimeSeriesLayer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_time_series_layer_with_http_info(id, layer_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_time_series_layer_with_http_info(id, layer_id, **kwargs)  # noqa: E501
            return data

    def get_time_series_layer_with_http_info(self, id, layer_id, **kwargs):  # noqa: E501
        """get a layer for the given time series id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_time_series_layer_with_http_info(id, layer_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Id of the time series this layer belongs to (required)
        :param int layer_id: Id of the layer to retrieve (required)
        :return: TimeSeriesLayer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id', 'layer_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_time_series_layer" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_time_series_layer`")  # noqa: E501
        # verify the required parameter 'layer_id' is set
        if ('layer_id' not in local_var_params or
                local_var_params['layer_id'] is None):
            raise ValueError("Missing the required parameter `layer_id` when calling `get_time_series_layer`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'layer_id' in local_var_params:
            path_params['layerId'] = local_var_params['layer_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/timeseries/{id}/layers/{layerId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TimeSeriesLayer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def has_annotations(self, id, **kwargs):  # noqa: E501
        """returns true if any annotations exist for the time series package  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.has_annotations(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Id of the timeseries package to aggregate annotations for (required)
        :return: bool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.has_annotations_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.has_annotations_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def has_annotations_with_http_info(self, id, **kwargs):  # noqa: E501
        """returns true if any annotations exist for the time series package  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.has_annotations_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Id of the timeseries package to aggregate annotations for (required)
        :return: bool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method has_annotations" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `has_annotations`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/timeseries/{id}/hasAnnotations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='bool',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_channel(self, id, channel_id, time_series_channel_write_request, **kwargs):  # noqa: E501
        """update an existing channel object in the graph  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_channel(id, channel_id, time_series_channel_write_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str channel_id: (required)
        :param TimeSeriesChannelWriteRequest time_series_channel_write_request: (required)
        :return: ChannelDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_channel_with_http_info(id, channel_id, time_series_channel_write_request, **kwargs)  # noqa: E501
        else:
            (data) = self.update_channel_with_http_info(id, channel_id, time_series_channel_write_request, **kwargs)  # noqa: E501
            return data

    def update_channel_with_http_info(self, id, channel_id, time_series_channel_write_request, **kwargs):  # noqa: E501
        """update an existing channel object in the graph  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_channel_with_http_info(id, channel_id, time_series_channel_write_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str channel_id: (required)
        :param TimeSeriesChannelWriteRequest time_series_channel_write_request: (required)
        :return: ChannelDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id', 'channel_id', 'time_series_channel_write_request']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_channel" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_channel`")  # noqa: E501
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in local_var_params or
                local_var_params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `update_channel`")  # noqa: E501
        # verify the required parameter 'time_series_channel_write_request' is set
        if ('time_series_channel_write_request' not in local_var_params or
                local_var_params['time_series_channel_write_request'] is None):
            raise ValueError("Missing the required parameter `time_series_channel_write_request` when calling `update_channel`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'channel_id' in local_var_params:
            path_params['channelId'] = local_var_params['channel_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'time_series_channel_write_request' in local_var_params:
            body_params = local_var_params['time_series_channel_write_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/timeseries/{id}/channels/{channelId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ChannelDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_channel_0(self, id, channel_id, time_series_channel_write_request, **kwargs):  # noqa: E501
        """update an existing channel object in the graph  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_channel_0(id, channel_id, time_series_channel_write_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str channel_id: (required)
        :param TimeSeriesChannelWriteRequest time_series_channel_write_request: (required)
        :return: ChannelDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_channel_0_with_http_info(id, channel_id, time_series_channel_write_request, **kwargs)  # noqa: E501
        else:
            (data) = self.update_channel_0_with_http_info(id, channel_id, time_series_channel_write_request, **kwargs)  # noqa: E501
            return data

    def update_channel_0_with_http_info(self, id, channel_id, time_series_channel_write_request, **kwargs):  # noqa: E501
        """update an existing channel object in the graph  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_channel_0_with_http_info(id, channel_id, time_series_channel_write_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: (required)
        :param str channel_id: (required)
        :param TimeSeriesChannelWriteRequest time_series_channel_write_request: (required)
        :return: ChannelDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id', 'channel_id', 'time_series_channel_write_request']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_channel_0" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_channel_0`")  # noqa: E501
        # verify the required parameter 'channel_id' is set
        if ('channel_id' not in local_var_params or
                local_var_params['channel_id'] is None):
            raise ValueError("Missing the required parameter `channel_id` when calling `update_channel_0`")  # noqa: E501
        # verify the required parameter 'time_series_channel_write_request' is set
        if ('time_series_channel_write_request' not in local_var_params or
                local_var_params['time_series_channel_write_request'] is None):
            raise ValueError("Missing the required parameter `time_series_channel_write_request` when calling `update_channel_0`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'channel_id' in local_var_params:
            path_params['channelId'] = local_var_params['channel_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'time_series_channel_write_request' in local_var_params:
            body_params = local_var_params['time_series_channel_write_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/timeseries/{id}/channels/{channelId}/properties', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ChannelDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_time_series_annotation(self, id, layer_id, annotation_id, time_series_annotation_write_request, **kwargs):  # noqa: E501
        """Update an annotation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_time_series_annotation(id, layer_id, annotation_id, time_series_annotation_write_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Id of the time series the annotation belongs to (required)
        :param int layer_id: Id of the layer the annotation belongs to (required)
        :param int annotation_id: Id of the annotation to update (required)
        :param TimeSeriesAnnotationWriteRequest time_series_annotation_write_request: (required)
        :return: TimeSeriesAnnotation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_time_series_annotation_with_http_info(id, layer_id, annotation_id, time_series_annotation_write_request, **kwargs)  # noqa: E501
        else:
            (data) = self.update_time_series_annotation_with_http_info(id, layer_id, annotation_id, time_series_annotation_write_request, **kwargs)  # noqa: E501
            return data

    def update_time_series_annotation_with_http_info(self, id, layer_id, annotation_id, time_series_annotation_write_request, **kwargs):  # noqa: E501
        """Update an annotation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_time_series_annotation_with_http_info(id, layer_id, annotation_id, time_series_annotation_write_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Id of the time series the annotation belongs to (required)
        :param int layer_id: Id of the layer the annotation belongs to (required)
        :param int annotation_id: Id of the annotation to update (required)
        :param TimeSeriesAnnotationWriteRequest time_series_annotation_write_request: (required)
        :return: TimeSeriesAnnotation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id', 'layer_id', 'annotation_id', 'time_series_annotation_write_request']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_time_series_annotation" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_time_series_annotation`")  # noqa: E501
        # verify the required parameter 'layer_id' is set
        if ('layer_id' not in local_var_params or
                local_var_params['layer_id'] is None):
            raise ValueError("Missing the required parameter `layer_id` when calling `update_time_series_annotation`")  # noqa: E501
        # verify the required parameter 'annotation_id' is set
        if ('annotation_id' not in local_var_params or
                local_var_params['annotation_id'] is None):
            raise ValueError("Missing the required parameter `annotation_id` when calling `update_time_series_annotation`")  # noqa: E501
        # verify the required parameter 'time_series_annotation_write_request' is set
        if ('time_series_annotation_write_request' not in local_var_params or
                local_var_params['time_series_annotation_write_request'] is None):
            raise ValueError("Missing the required parameter `time_series_annotation_write_request` when calling `update_time_series_annotation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'layer_id' in local_var_params:
            path_params['layerId'] = local_var_params['layer_id']  # noqa: E501
        if 'annotation_id' in local_var_params:
            path_params['annotationId'] = local_var_params['annotation_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'time_series_annotation_write_request' in local_var_params:
            body_params = local_var_params['time_series_annotation_write_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/timeseries/{id}/layers/{layerId}/annotations/{annotationId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TimeSeriesAnnotation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_time_series_layer(self, id, layer_id, layer_request, **kwargs):  # noqa: E501
        """update layer for the given time series id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_time_series_layer(id, layer_id, layer_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Id of the time series this layer belongs to (required)
        :param int layer_id: Id of the layer to update (required)
        :param LayerRequest layer_request: Layer properties to update (required)
        :return: TimeSeriesLayer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_time_series_layer_with_http_info(id, layer_id, layer_request, **kwargs)  # noqa: E501
        else:
            (data) = self.update_time_series_layer_with_http_info(id, layer_id, layer_request, **kwargs)  # noqa: E501
            return data

    def update_time_series_layer_with_http_info(self, id, layer_id, layer_request, **kwargs):  # noqa: E501
        """update layer for the given time series id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_time_series_layer_with_http_info(id, layer_id, layer_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Id of the time series this layer belongs to (required)
        :param int layer_id: Id of the layer to update (required)
        :param LayerRequest layer_request: Layer properties to update (required)
        :return: TimeSeriesLayer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['id', 'layer_id', 'layer_request']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_time_series_layer" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in local_var_params or
                local_var_params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_time_series_layer`")  # noqa: E501
        # verify the required parameter 'layer_id' is set
        if ('layer_id' not in local_var_params or
                local_var_params['layer_id'] is None):
            raise ValueError("Missing the required parameter `layer_id` when calling `update_time_series_layer`")  # noqa: E501
        # verify the required parameter 'layer_request' is set
        if ('layer_request' not in local_var_params or
                local_var_params['layer_request'] is None):
            raise ValueError("Missing the required parameter `layer_request` when calling `update_time_series_layer`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'layer_id' in local_var_params:
            path_params['layerId'] = local_var_params['layer_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'layer_request' in local_var_params:
            body_params = local_var_params['layer_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/timeseries/{id}/layers/{layerId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TimeSeriesLayer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)
